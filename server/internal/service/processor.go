package service

import (
	"encoding/json"
	"fmt"
	"image"
	"image/jpeg"
	"log"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/aitjcize/photoframe-server/server/pkg/photoframe"
	_ "golang.org/x/image/bmp" // Register BMP decoder
)

type ProcessorService struct {
}

func NewProcessorService() *ProcessorService {
	return &ProcessorService{}
}

func (s *ProcessorService) MapProcessingSettings(settings *photoframe.ProcessingSettings, palette *photoframe.Palette) map[string]string {
	opts := make(map[string]string)
	if settings == nil {
		return opts
	}

	opts["exposure"] = fmt.Sprintf("%v", settings.Exposure)
	opts["saturation"] = fmt.Sprintf("%v", settings.Saturation)
	if settings.ToneMode != "" {
		opts["tone-mode"] = settings.ToneMode
	}
	opts["contrast"] = fmt.Sprintf("%v", settings.Contrast)
	if settings.ToneMode == "scurve" {
		opts["scurve-strength"] = fmt.Sprintf("%v", settings.Strength)
		opts["scurve-shadow"] = fmt.Sprintf("%v", settings.ShadowBoost)
		opts["scurve-highlight"] = fmt.Sprintf("%v", settings.HighlightCompress)
		opts["scurve-midpoint"] = fmt.Sprintf("%v", settings.Midpoint)
	}
	if settings.ColorMethod != "" {
		opts["color-method"] = settings.ColorMethod
	}
	if settings.DitherAlgorithm != "" {
		opts["dither-algorithm"] = settings.DitherAlgorithm
	}
	if settings.CompressDynamicRange {
		opts["compress-dynamic-range"] = "" // Boolean flag
	}

	if palette != nil {
		paletteWrapper := map[string]interface{}{
			"theoretical": map[string]interface{}{
				"black":  map[string]int{"r": 0, "g": 0, "b": 0},
				"white":  map[string]int{"r": 255, "g": 255, "b": 255},
				"yellow": map[string]int{"r": 255, "g": 255, "b": 0},
				"red":    map[string]int{"r": 255, "g": 0, "b": 0},
				"blue":   map[string]int{"r": 0, "g": 0, "b": 255},
				"green":  map[string]int{"r": 0, "g": 255, "b": 0},
			},
			"perceived": palette,
		}
		paletteJSON, err := json.Marshal(paletteWrapper)
		if err == nil {
			opts["palette"] = string(paletteJSON)
		}
	}

	return opts
}

func (s *ProcessorService) ProcessImage(img image.Image, options map[string]string) ([]byte, []byte, error) {
	// 1. Create temp directory for this operation
	tmpDir, err := os.MkdirTemp("", "process-*")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	// 2. Save input image
	inputPath := filepath.Join(tmpDir, "source.jpg")
	f, err := os.Create(inputPath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input file: %w", err)
	}

	// Encode as JPEG
	if err := jpeg.Encode(f, img, &jpeg.Options{Quality: 95}); err != nil {
		f.Close()
		return nil, nil, fmt.Errorf("failed to encode input image: %w", err)
	}
	f.Close()

	// 3. Prepare output paths
	outputPath := filepath.Join(tmpDir, "output.png")
	thumbPath := filepath.Join(tmpDir, "thumbnail.jpg")

	// 4. Prepare CLI arguments for epaper-image-convert
	// epaper-image-convert input.jpg output.png -d WxH -t thumbnail.jpg [options]
	args := []string{inputPath, outputPath}

	// Add dimension if specified
	if dimension, ok := options["dimension"]; ok {
		args = append(args, "-d", dimension)
	}

	// Add thumbnail output
	args = append(args, "-t", thumbPath)

	// Add other options (excluding dimension which we already handled)
	for k, v := range options {
		if k != "dimension" {
			if v == "" {
				// Boolean flag
				args = append(args, "--"+k)
			} else {
				args = append(args, "--"+k, v)
			}
		}
	}

	// Make verbose
	args = append(args, "-v")
	log.Println("Processing image with arguments: ", args)

	cmd := exec.Command("epaper-image-convert", args...)

	// Capture output for debugging
	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Printf("CLI execution failed: %s\nOutput: %s\n", err, string(output))
		return nil, nil, fmt.Errorf("cli execution failed: %s", err)
	}

	// Log CLI output for debug
	log.Printf("CLI Output: %s\n", string(output))

	// 5. Read outputs
	processedBytes, err := os.ReadFile(outputPath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read processed image: %s. CLI Output: %s", err, string(output))
	}

	thumbBytes, err := os.ReadFile(thumbPath)
	if err != nil {
		// If thumbnail missing, maybe acceptable? But CLI should generate it.
		// We'll return nil for thumbBytes if missing, handling it gracefully
		fmt.Printf("Warning: Thumbnail not generated by CLI. Path: %s\n", thumbPath)
		thumbBytes = nil
	} else {
		// fmt.Printf("Processor: Successfully generated thumb (%d bytes)\n", len(thumbBytes))
	}

	return processedBytes, thumbBytes, nil
}
